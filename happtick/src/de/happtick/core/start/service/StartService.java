package de.happtick.core.start.service;

import java.util.List;

import de.happtick.configuration.ApplicationConfiguration;
import de.happtick.core.MasterTable;
import de.happtick.core.exception.HapptickException;
import de.notEOF.core.enumeration.EventType;
import de.notEOF.core.exception.ActionFailedException;
import de.notEOF.core.interfaces.NotEOFEvent;
import de.notEOF.core.interfaces.Service;
import de.notEOF.core.service.BaseService;
import de.notIOC.logging.LocalLog;

/**
 * Start einer Anwendung kann evtl. wahlweise entweder ueber startApplication()
 * oder mit Hilfe des StartEvents und dementsprechend processEvent() ausgeloest
 * werden.
 * 
 * @author Dirk
 * 
 */
public class StartService extends BaseService {

    private String clientIp;
    private String startId;

    /**
     * This method is called by BaseService directly when the connection with
     * client is established.
     */
    public void implementationFirstSteps() {
        // register at master tables
        MasterTable.addService(this);
    }

    public void implementationLastSteps() {
        // deregister from master tables
        try {
            MasterTable.removeService(this);
        } catch (HapptickException e) {
            LocalLog.error("Fehler bei Beenden des StartService. ServiceId: " + this.serviceId + "; ClientIp: " + clientIp + "; Client StartId: " + startId);
        }
    }

    public String getClientIp() {
        return this.clientIp;
    }

    /**
     * The starterId is generated by the StartClient.
     * <p>
     * This id is used to distinguish between manual started processes and
     * processes which are started by the scheduler (StartService).
     * 
     * @return The starterId generated by StartClient or NULL.
     */
    public String getStartId() {
        return startId;
    }

    /**
     * Ignition of application start.
     * <p>
     * The client is in waiting mode. With this method the service wakes him up
     * and tells him to start the application on client side.
     * 
     * @param applicationConfiguration
     *            Contains informations about the application (e.g. executable
     *            path).
     * @return The StartClient generates a start id. This start he delivers to
     *         the service. The start id is the return value here.
     */
    public String startApplication(ApplicationConfiguration applicationConfiguration) {
        return null;
    }

    /**
     * 
     */
    public synchronized void processEvent(Service service, NotEOFEvent event) throws ActionFailedException {

        // 1. StartEvent?
        // 2. clientIp = ip des eigenen Client
        // 3. generiere ApplicationConfiguration
        // 3. rufe startApplication auf
    }

    @Override
    public Class<?> getCommunicationTagClass() {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public boolean isLifeSignSystemActive() {
        // TODO Auto-generated method stub
        return false;
    }

    @Override
    public void processClientMsg(Enum<?> arg0) throws ActionFailedException {
        // TODO Auto-generated method stub

        // anmelden an MasterTable
        // nach initialisierung durch client...
    }

    public List<EventType> getObservedEvents() {
        // TODO Auto-generated method stub
        return null;
    }

}
